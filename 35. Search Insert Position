/*
Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with O(log n) runtime complexity.

 

Example 1:

Input: nums = [1,3,5,6], target = 5
Output: 2
Example 2:

Input: nums = [1,3,5,6], target = 2
Output: 1
Example 3:

Input: nums = [1,3,5,6], target = 7
Output: 4
*/

class Solution(object):
    def searchInsert(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        # Initialize the boundaries for binary search
        left = 0
        right = len(nums) - 1

        # Continue searching as long as the search range is valid
        while left <= right:
            # Calculate the middle index (floor division)
            mid = (left + right) // 2

            # Case 1: Target value found, return its index
            if nums[mid] == target:
                return mid
            
            # Case 2: Target is greater than the middle value, 
            # search the right half
            elif nums[mid] < target:
                left = mid + 1
            
            # Case 3: Target is smaller than the middle value, 
            # search the left half
            else: # (nums[mid] > target)
                right = mid - 1
        
        # If the target is not found, 'left' will be the correct 
        # insertion point to maintain sorted order.
        return left
