/*
You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.
Merge nums1 and nums2 into a single array sorted in non-decreasing order.
The final sorted array should not be returned by the function, but instead be stored inside the array nums1. 
To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.

Example 1:
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]
Explanation: The arrays we are merging are [1,2,3] and [2,5,6].
The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.

Example 2:
Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1]
Explanation: The arrays we are merging are [1] and [].
The result of the merge is [1].

Example 3:
Input: nums1 = [0], m = 0, nums2 = [1], n = 1
Output: [1]
Explanation: The arrays we are merging are [] and [1].
The result of the merge is [1].
Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.

Constraints:
nums1.length == m + n
nums2.length == n
0 <= m, n <= 200
1 <= m + n <= 200
-109 <= nums1[i], nums2[j] <= 109
*/

class Solution(object):
    def merge(self, nums1, m, nums2, n):
        """
        :type nums1: List[int]
        :type m: int
        :type nums2: List[int]
        :type n: int
        :rtype: None Do not return anything, modify nums1 in-place instead.
        """
        nums1[m:] = nums2
        nums1.sort()



-------------------------------------------------
ðŸ“ Troubleshooting: Why my initial approach failed
In my first attempt at the Merge Sorted Array problem, I used extend() and list comprehension. However, I missed two critical constraints of the problem. Here is a summary of my mistakes and what I learned.

1. Understanding In-place Modification
Mistake: I wrote nums1 = [x for x in nums1 if x != 0].

The Cause: In Python, this creates a new list object and assigns the name nums1 to it. 
However, the LeetCode judge checks the original memory address of the nums1 list passed into the function. Since I only reassigned the variable name, the original list remained unchanged in the eyes of the judge.

Lesson: To modify a list in-place, you must use slicing like nums1[:] = ... or access the indices directly.

2. 0 is a Placeholder, not just a value to delete
Mistake: I tried to filter out all 0s using a condition (if x != 0).

The Cause: The 0s at the end of nums1 are placeholders for nums2, but 0 can also be a valid integer within the input data. Blindly removing all zeros might delete actual data that belongs in the final sorted array.

Lesson: Use the provided variables m and n to target the exact range of the array (e.g., nums1[m:]).

3. extend() vs. Slicing Assignment
Mistake: I used nums1.extend(nums2).

The Cause: nums1 is already initialized with a size of m + n. Using extend() increases the total length to m + n + n. This violates the fixed-size constraint of the input array.

Lesson: To fill the pre-allocated space, use slicing assignment: nums1[m:] = nums2.
